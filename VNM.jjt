YonkoOzy
ozydrag
0.1%

Wise one ðŸ§  â€” 2024-04-27 7:53 PM
no one cares about you
fuck u? â€” 2024-10-03 11:11 PM
@Wise one ðŸ§ 
Image
Wise one ðŸ§  â€” 2024-10-03 11:18 PM
thanks man
superstar â€” 2024-10-04 7:17 AM
Ayesha thatâ€™s so sadðŸ˜­
ðŸ˜­
ðŸ˜­
ðŸ˜­
ðŸ˜­
ðŸ˜­
Why didnâ€™t you switch to the other guys section
BiTcHlEsS â€” 2024-10-04 3:19 PM
Seeing that you got Khalid and still not switching is something I wonâ€™t understand
superstar â€” 2024-10-10 9:04 PM
Image
superstar â€” 2024-10-10 9:24 PM
Image
BiTcHlEsS â€” 2025-09-25 10:57 AM
Attachment file type: acrobat
CPS843_Assignment_1.pdf
7.27 MB
Attachment file type: archive
843-Quizzes.zip
2.41 MB
Attachment file type: acrobat
Assignment2_Andrew_Le_501090188.pdf
722.39 KB
superstar â€” 2025-09-30 5:37 PM
https://www.youtube.com/watch?v=OIKL6wFjFOo&ab_channel=NesoAcademy
YouTube
Neso Academy
Introduction to Parsers
Image
https://www.youtube.com/watch?v=wQjppolFdas&ab_channel=NesoAcademy
YouTube
Neso Academy
Ambiguous Grammar
Image
superstar â€” 2025-10-31 7:14 PM
https://drive.google.com/drive/u/1/folders/1uIOp7F3L2yj4dRl37f30XNTkUA7rAY-J
Google Drive
^768 project
Image
@Wise one ðŸ§ 
did your 768 project work
can you call me
superstar â€” 2025-11-10 7:15 PM
Project 3
options {
  IGNORE_CASE=false;
  MULTI=true;
  JJTREE_OUTPUT_DIRECTORY="AST";
  VISITOR=true;
  NODE_DEFAULT_VOID=true;
Expand
message.txt
9 KB
superstar
 pinned a message to this channel. See all pinned messages. â€” 2025-11-10 7:15 PM
superstar â€” 2025-11-10 7:23 PM
chmod +x run t
chmod +x runtests
superstar â€” 2025-11-12 10:22 AM
NOO BRO HE CHANGES SHIT
superstar â€” 2025-11-12 11:38 AM
Okay i think it should still be fine
Image
BiTcHlEsS â€” 2025-11-22 12:50 PM
Image
looks like it still works
superstar â€” 2025-11-22 12:52 PM
Okay perfect thank you
BiTcHlEsS â€” 2025-11-22 1:09 PM
idk how much i can change this up tbh
fuck u? â€” 2025-11-22 1:10 PM
Spacing and comments ?
BiTcHlEsS â€” 2025-11-22 1:11 PM
yeah thats pretty much what i did
superstar â€” 2025-11-22 1:11 PM
Wdym just gpt it no
BiTcHlEsS â€” 2025-11-22 1:12 PM
you cant change the actual var names cuz they gave us them
superstar â€” 2025-11-22 1:12 PM
Structure of the code
Move stuff around
fake ahraz â€” 2025-11-23 7:09 PM
options {
  IGNORE_CASE=false;
  MULTI=true;
  JJTREE_OUTPUT_DIRECTORY="AST";
  VISITOR=true;
  // standard options setup
Expand
message.txt
7 KB
superstar â€” 2025-11-25 11:49 AM
ill do project 4
superstar â€” 2025-11-25 2:44 PM
LAB IS DONE GANGY
Image
VNM.jjt
options {
  IGNORE_CASE=false;
  MULTI=true;	// This will generate one AST class for each non-suppressed non-terminal
  JJTREE_OUTPUT_DIRECTORY="AST";  // This will put all your AST classes in the AST directory
  VISITOR=true;	// This won't be used until the next assignment, but will be needed to make your assignment compile properly
  VISITOR_EXCEPTION="Exception";
Expand
message.txt
8 KB
VNMEval.java
public class VNMEval implements VNMVisitor {

    /* Utility helpers */
    private int asInt(Object o) { return ((Integer)o).intValue(); }
    private boolean asBool(Object o) { return ((Boolean)o).booleanValue(); }
Expand
message.txt
8 KB
Image
superstar â€” 2025-11-25 7:07 PM
#include <stdio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdlib.h>
Expand
peer.c
11 KB
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h> 
#include <stdlib.h>
#include <string.h>
#include <netdb.h> 
Expand
server.c
9 KB
@BiTcHlEsS  you can use this to submit
@BookBoy
fuck u? â€” 2025-11-25 7:15 PM
@BookBoy can you please review the codes and learn them especially the peer file
BookBoy â€” 2025-11-25 10:30 PM
Ok
Js for u
I will
Cus u asked nucely
superstar â€” 2025-11-25 10:50 PM
Image
BiTcHlEsS â€” Yesterday at 1:51 PM
Image
BookBoy â€” 7:08 PM
options {
  IGNORE_CASE=false;
  MULTI=true;	// This will generate one AST class for each non-suppressed non-terminal
  JJTREE_OUTPUT_DIRECTORY="AST";  // This will put all your AST classes in the AST directory
  VISITOR=true;	// This won't be used until the next assignment, but will be needed to make your assignment compile properly
  VISITOR_EXCEPTION="Exception";
Expand
message.txt
9 KB
ignore this^
ï»¿
options {
  IGNORE_CASE=false;
  MULTI=true;	// This will generate one AST class for each non-suppressed non-terminal
  JJTREE_OUTPUT_DIRECTORY="AST";  // This will put all your AST classes in the AST directory
  VISITOR=true;	// This won't be used until the next assignment, but will be needed to make your assignment compile properly
  VISITOR_EXCEPTION="Exception";
}

PARSER_BEGIN(VNM)

public class VNM {
}

PARSER_END(VNM)

TOKEN_MGR_DECLS : 
{

}

SKIP : {
  " "     
| "\t"    
| "\n"    
| "\r" 
}

TOKEN : 
{
  < LESS: "<">
| < LE:     "<="  >
| < GREAT:  ">"   >
| < GE:     ">="  >
| < EQ:     "=="  >
| < NEQ:    "!="  >
| < IN:     "=in" >
| < NOTIN:  "!in" >
| < PLUS:	  "+"   >
| < MINUS:	"-"   >
| < TIMES:	"*"   >
| < DIV:	  "/"   >
| < AND:	  "&"   >
| < VBAR:	  "|"   >
| < NOT:	  "!"   >
| < ASSGN:	":="   >
| < LRND:	  "("   >
| < LSQU:	  "["   >
| < RRND:	  ")"   >
| < RSQU:	  "]"   >
| < COMMA:	","   >
| < SCOL:	  ";"   >
| < TRUE:	  "#1"  >
| < FALSE:	"#0"  >
| < RANGE:	".."  >
}

TOKEN [IGNORE_CASE]:
{
  < DO:"DO">
| < WHILE:"WHILE">
| < FOR:"FOR">
| < IF:"IF">
| < THEN:"THEN">
| < ELIF:"ELIF">
| < ELSE:"ELSE">
| < FI:"FI">
| < FUNCTION:"FUNCTION">
| < RETURN:"RETURN">
| < END:"END">
| < PRINT:"PRINT">
| < PRINTLN:"PRINTLN">
| < VAR:"VAR">
}

TOKEN : 
{
  < #DIGIT:	["0"-"9"]>
| < #LOWER:	["a"-"z"]>
| < #UPPER:	["A"-"Z"]>
| < #LETTER: ["a"-"z","A"-"Z"]>

// string / number / ids
| < STRING: "\"" (~["\""])* "\"" > 
| < NUMBER:	(<DIGIT>)+ >
| < IDNUM:  "#" <LETTER>(<LETTER>|<DIGIT>)* >  
| < IDBOOL:	"?" <LETTER>(<LETTER>|<DIGIT>)* >
| < IDVEC:  "v_" (<LETTER>|<DIGIT>)+ >  
}

// Special tokens are saved, but not sent to the parser
SPECIAL_TOKEN : 
{
  <COMMENT_SINGLE: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}



// ==================================================
//                  PARSER BEGINS
// ==================================================

SimpleNode start	() #void :
{}
{  S()  { return (SimpleNode) (jjtree.popNode()); }
| < EOF > {throw new ParseException("End of File.");}
}

// entry point to parser. Called by TestVNM.java
void S() throws ParseException	#void	 :
{}
{	statement_LL1() ";"
| LOOKAHEAD(identifier() ":=") assign_stat() ";" 
| expression() ";" 
| boolean_call() ";"
}

//------------------------    STATEMENTS, BODIES AND CLAUSES -----------------------------------

// These are all the statements which can be differentiated from each other 
// with a single lookahead
void statement_LL1()	#void	 :
{}
{	var_decl()
| fn_decl()
| return_stat()
| print_stat()
| println_stat()
| if_stat()
| for_stat()
| while_stat()
}

// These are the statements not at the top level, i.e. inside bodies or clauses
// Maintain structural integrity of assignments and function calls by not factoring them
// and using a lookahead to distinguish between them

void statement()	#void :
{}
{	statement_LL1()
| LOOKAHEAD(2) fn_call()
| assign_stat()
}

void body()		 :
{}
{	(statement() ";")*
}

void clause()		 :
{}
{	(statement() ";")+
}

//---------------------------   DECLARATIONS ------------------------------------------------

void var_decl()	#void :
{}
{	<VAR> var_list()
}

void var_list()	#void :
{}
{	(identifier() ("," identifier())*) #var_decl
}

void fn_decl()		 :
{}
{	<FUNCTION> identifier() "(" (ident_list())? ")" body() <END>
}

void ident_list()	 :
{}
{	identifier() ("," identifier())*
}


//---------------------------   FUNCTION CALLS AND RETURNS ----------------------------------

// Separate out function calls that can be used in expressions (numbers and vectors),
// from those used in conditions (boolean).
void fn_call()		 :
{}
{	idnum() "(" (exp_list())? ")"
|	idvec() "(" (exp_list())? ")"
}

void boolean_call()		 :
{}
{	idbool() "(" (exp_list())? ")"
}

void exp_list()	 :
{}
{	expression() ("," expression())*
}

// Since we split function calls by boolean and numerical,
// we need an explicit condition list
void condition_list() :
{}
{ condition() ("," condition())*
}

void return_stat()	#Return :
{}
{	<RETURN> returnval()
}

// syntactic lookahead to distinguish conditions and expressions.
void returnval()	#void :
{}
{	LOOKAHEAD(condition()) condition()
| expression() 
}

void print_stat() #Print :
{}
{	<PRINT> print_list()
}

void println_stat() #Print_ln :
{}
{ <PRINTLN> (print_list())?
}

// *** FIXED: allow bool_simple (TRUE/FALSE) in print_list ***
void print_list() #void :
{}
{
  ( expression()
  | string()
  | idbool()
  | bool_simple()
  )
  ( ","
    ( expression()
    | string()
    | idbool()
    | bool_simple()
    )
  )*
}

void assign_stat() #Assign :
{}
{ idnum() ":=" expression()
| idbool() ":=" condition()
| idvec() ":=" vec_const()
}

void if_stat()		#If :
{}
{	<IF> condition() <THEN> clause() else_clause() <FI>
}

void else_clause	() #void:
{}
{	 (<ELIF> condition() <THEN> clause() else_clause()) #If
|  <ELSE> clause()
|  {} #NULL
}

void for_stat()	#For :
{}
{	<FOR> idnum() <IN> exp_list() <DO> body() <END>
}

void while_stat() #While	 :
{}
{	<WHILE> condition() <DO> body() <END>
}


//---------------------------   CONDITIONS ---------------------------------------------------

void condition()	#void :
{}
{	(and_clause() ("|" and_clause())*) #or(>1)
}

void and_clause()	#void :
{}
{	(not_clause() ("&" not_clause())*) #and(>1)
}

// syntactic lookahead to distinguish comparisons and conditions.
void not_clause()	#void :
{}
{	"!" not_clause()  #not
| LOOKAHEAD(expression() comparator()) comparison() 
| "(" condition() ")"
| LOOKAHEAD(2) boolean_call()
| bool_simple()
}

void comparison()	 :
{}
{	expression() comparator() expression()
}

void comparator()	 #void :
{}
{	"<"   #le
| "<="  #leq
| ">"   #gre
| ">="  #geq
| "=="  #eq
| "!="  #neq
| "=in" #in
| "!in" #notin
}


//---------------------------   EXPRESSIONS ------------------------------------------------

void expression()	#void	 :
{}
{	("+" product() (summand())*) #sum(>1)
|	(neg() (summand())*)         #sum
|	(product() (summand())*)     #sum(>1)
}

void neg() :
{}
{	"-" product() 
}

void summand() #void :
{}
{	"+" product() #pos
|	"-" product() #neg
}
 
void product() #void :
{}
{	term() moreterms()
}

void moreterms() #void :
{}
{	"*" term() #mul(2) moreterms()
|	"/" term() #div(2) moreterms()
|	"%" term() #mod(2) moreterms()
| {}
}

// use a lookahead to distinguish fn_call from simple_term.
void term()		#void :
{}
{	"(" expression() ")"
| LOOKAHEAD(2) fn_call()
| simple_term()
}

void simple_term()	#void :
{}
{	idnum()
| idvec()
| number()
| vec_const() 
}

// vectors & vector booleans
void vec_const()	 :
{}
{	
  LOOKAHEAD("[" expression()) "[" (exp_list())? "]"
| "[" (condition_list())? "]"
}

void identifier()	#void :
{}
{	idnum()
| idbool()
| idvec() 
}

void bool_simple()	#void	 :
{}
{	idbool() 
| <TRUE>  #TRUE
| <FALSE> #FALSE
}   


//---------------------------   TERMINALS WITH VALUES  --------------------------------------

// *** FIXED: use t.image instead of t.getValue() everywhere ***

void idvec ()  :
{ Token t; }
{ t = <IDVEC>  { jjtThis.jjtSetValue(t.image); } }

void idnum () :
{ Token t; }
{ t = <IDNUM>  { jjtThis.jjtSetValue(t.image); } }  

void idbool ()  :
{ Token t; }
{ t = <IDBOOL> { jjtThis.jjtSetValue(t.image); } }

void number () :
{ Token t; }
{ t = <NUMBER> { jjtThis.jjtSetValue(t.image); } }

void string () :
{ Token t; }
{ t = <STRING> { jjtThis.jjtSetValue(t.image); } }
message.txt
8 KB